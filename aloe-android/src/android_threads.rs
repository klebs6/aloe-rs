crate::ix!();

//-------------------------------------------[.cpp/Aloe/modules/aloe_core/native/aloe_android_Threads.cpp]

/**
  | -----------
  | @note
  | 
  | a lot of methods that you'd expect to
  | find in this file actually live in aloe_posix_SharedCode.h!
  |
  */
#[cfg(target_os="android")]
lazy_static!{
    /*
    #define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD, CALLBACK) \
     FIELD (activityInfo, "activityInfo", "Landroid/content/pm/ActivityInfo;")

    DECLARE_JNI_CLASS (AndroidResolveInfo, "android/content/pm/ResolveInfo")
    #undef JNI_CLASS_MEMBERS
    */
}

#[cfg(target_os="android")]
lazy_static!{
    /*
    JavaVM* androidJNIJavaVM = nullptr;
    jobject androidApkContext = nullptr;
    */
}

#[cfg(target_os="android")]
pub fn get_env() -> *mut JNIEnv {
    
    todo!();
    /*
        if (androidJNIJavaVM != nullptr)
        {
            JNIEnv* env;
            androidJNIJavaVM->AttachCurrentThread (&env, nullptr);

            return env;
        }

        // You did not call Thread::initialiseALOE which must be called at least once in your apk
        // before using any Aloe APIs. The Proaloer will automatically generate java code
        // which will invoke Thread::initialiseALOE for you.
        jassertfalse;
        return nullptr;
    */
}

#[JNICALL]
#[cfg(target_os="android")]
pub fn aloe_javainitialisealoe(
        env:     *mut JNIEnv,
        jclass:  jobject,
        context: jobject)  {
    
    todo!();
    /*
        Thread::initialiseALOE (env, context);
    */
}

#[JNIEXPORT]
#[cfg(target_os="android")]
pub fn jni_on_load(
        vm: *mut JavaVM,
        _1: *mut c_void) -> i32 {
    
    todo!();
    /*
        // Huh? JNI_OnLoad was called two times!
        jassert (androidJNIJavaVM == nullptr);

        androidJNIJavaVM = vm;

        auto* env = getEnv();

        // register the initialisation function
        auto aloeJavaClass = env->FindClass("com/rmsl/aloe/Java");

        if (aloeJavaClass != nullptr)
        {
            JNINativeMethod method {"initialiseALOE", "(Landroid/content/Context;)V",
                                    reinterpret_cast<void*> (aloe_JavainitialiseALOE)};

            auto status = env->RegisterNatives (aloeJavaClass, &method, 1);
            jassert (status == 0);
        }
        else
        {
            // com.rmsl.aloe.Java class not found. Apparently this project is a library
            // or was not generated by the Proaloer. That's ok, the user will have to
            // call Thread::initialiseALOE manually
            env->ExceptionClear();
        }

        JNIClassBase::initialiseAllClasses (env);

        return JNI_VERSION_1_2;
    */
}

#[cfg(target_os="android")]
pub fn get_current_activity() -> LocalRef<jobject> {
    
    todo!();
    /*
        return AloeActivityWatcher::getInstance().getCurrent();
    */
}

#[cfg(target_os="android")]
pub fn get_main_activity() -> LocalRef<jobject> {
    
    todo!();
    /*
        return AloeActivityWatcher::getInstance().getMain();
    */
}

#[cfg(target_os="android")]
pub fn aloe_is_running_under_debugger() -> bool {
    
    todo!();
    /*
        Vec<String> lines;
        File ("/proc/self/status").readLines (lines);

        for (int i = lines.size(); --i >= 0;) // (NB - it's important that this runs in reverse order)
            if (lines[i].upToFirstOccurrenceOf (":", false, false).trim().equalsIgnoreCase ("TracerPid"))
                return (lines[i].fromFirstOccurrenceOf (":", false, false).trim().getIntValue() > 0);

        return false;
    */
}
