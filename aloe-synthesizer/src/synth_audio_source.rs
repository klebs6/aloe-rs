crate::ix!();

/**
  | This is an audio source that streams
  | the output of our demo synth.
  |
  */
pub struct SynthAudioSource<'a> {

    /**
      | this collects real-time midi messages from
      | the midi input device, and turns them into
      | blocks that we can process in our audio
      | callback
      */
    midi_collector: MidiMessageCollector,

    /**
      | this represents the state of which keys on
      | our on-screen keyboard are held down. When
      | the mouse is clicked on the keyboard
      | component, this object also generates midi
      | messages for this, which we can pass on to
      | our synth.
      */
    keyboard_state: &'a mut MidiKeyboardState,

    /**
      | the synth itself!
      |
      */
    synth:          Synthesizer,
}

impl<'a> PrepareToPlayAudioSource for SynthAudioSource<'a> {

    fn prepare_to_play(
        &mut self, 
        samples_per_block_expected: i32,
        sample_rate:                f64

    ) {
        
        todo!();
        /*
            midiCollector.reset (sampleRate);

            synth.setCurrentPlaybackSampleRate (sampleRate);
        */
    }
}

impl<'a> ReleaseResources for SynthAudioSource<'a> {
    
    fn release_resources(&mut self)  {
        
    }
}
    
impl<'a> GetNextAudioBlock for SynthAudioSource<'a> {

    fn get_next_audio_block(&mut self, buffer_to_fill: &AudioSourceChannelInfo)  {
        
        todo!();
        /*
            // the synth always adds its output to the audio buffer, so we have to clear it
            // first..
            bufferToFill.clearActiveBufferRegion();

            // fill a midi buffer with incoming messages from the midi input.
            MidiBuffer incomingMidi;
            midiCollector.removeNextBlockOfMessages (incomingMidi, bufferToFill.numSamples);

            // pass these messages to the keyboard state so that it can update the component
            // to show on-screen which keys are being pressed on the physical midi keyboard.
            // This call will also add midi messages to the buffer which were generated by
            // the mouse-clicking on the on-screen keyboard.
            keyboardState.processNextMidiBuffer (incomingMidi, 0, bufferToFill.numSamples, true);

            // and now get the synth to process the midi events and generate its output.
            synth.renderNextBlock (*bufferToFill.buffer, incomingMidi, 0, bufferToFill.numSamples);
        */
    }
}

impl<'a> SynthAudioSource<'a> {

    pub fn new(key_state: &mut MidiKeyboardState) -> Self {
    
        todo!();
        /*
        : keyboard_state(keyState),

            // Add some voices to our synth, to play the sounds..
            for (auto i = 0; i < 4; ++i)
            {
                synth.addVoice (new SineWaveVoice());   // These voices will play our custom sine-wave sounds..
                synth.addVoice (new SamplerVoice());    // and these ones play the sampled sounds
            }

            // ..and add a sound for them to play...
            setUsingSineWaveSound();
        */
    }
    
    pub fn set_using_sine_wave_sound(&mut self)  {
        
        todo!();
        /*
            synth.clearSounds();
            synth.addSound (new SineWaveSound());
        */
    }
    
    pub fn set_using_sampled_sound(&mut self)  {
        
        todo!();
        /*
            WavAudioFormat wavFormat;

            std::unique_ptr<AudioFormatReader> audioReader (wavFormat.createReaderFor (createAssetInputStream ("cello.wav").release(), true));

            BigInteger allNotes;
            allNotes.setRange (0, 128, true);

            synth.clearSounds();
            synth.addSound (new SamplerSound ("demo sound",
                                              *audioReader,
                                              allNotes,
                                              74,   // root midi note
                                              0.1,  // attack time
                                              0.1,  // release time
                                              10.0  // maximum sample length
                                              ));
        */
    }
}
