# Aloe Commands

Aloe Commands is a Rust library that provides a set of standard application command identifiers and a framework for managing and executing these commands within applications. It is designed to facilitate consistent command handling across applications by standardizing command IDs and providing utilities for command registration, mapping, and invocation.

## Features
- **Standard Commands**: Offers a predefined set of command IDs for common actions like Quit, Cut, Copy, Paste, etc., to promote interoperability across applications using the Aloe framework.
- **Command Management**: Includes traits and structures to register commands, manage key mappings, and perform commands, allowing for robust command handling mechanisms.
- **Command Invocation**: Supports direct command invocation and key press-based command triggering through a customizable mapping system.
- **KeyPress Mapping**: Provides facilities for mapping keypresses to commands, enabling flexible user input handling.

## Usage

To use this crate, add `aloe-commands` to your `Cargo.toml`:

```toml
[dependencies]
aloe-commands = "0.1.0"
```

Here's a basic example illustrating how to set up a command manager and register commands:

```rust
use aloe_commands::{ApplicationCommandManager, ApplicationCommandTarget, StandardApplicationCommandsIds};

struct MyApp;

impl ApplicationCommandTarget for MyApp {
    fn get_all_commands(&mut self, commands: &mut Vec<usize>) {
        commands.push(StandardApplicationCommandsIds::Quit.value());
    }

    fn get_command_info(&mut self, _command_id: usize, _result: &mut ApplicationCommandInfo) {
        // Fill in the command info details here.
    }

    fn perform(&mut self, _info: &ApplicationCommandTargetInvocationInfo) -> bool {
        // Define command execution logic here.
        true
    }
}

fn main() {
    let mut command_manager = ApplicationCommandManager::default();
    let mut my_app = MyApp;
    command_manager.register_all_commands_for_target(&mut my_app);
    // Now you can invoke commands and manage key mappings.
}
```

## Documentation

For more detailed information and advanced usage, please refer to the documentation within the library source files and the associated GitHub repository.

## License

This project is licensed under the [GPL-3.0 License](LICENSE).

---

*This README.md file was generated by an AI model and may not be 100% accurate, however, it should be pretty good.*

This crate is a translation of the JUCE module.

JUCE is a c++ software framework for developing high performance audio applications.

Usage falls under the GPLv3 as well as the JUCE commercial license.

See github.com/juce-framework/JUCE and the JUCE license page for details.

This crate is in the process of being translated from c++ to rust. For progress updates, please see the workspacer rust project. designed specifically for rust projects.
