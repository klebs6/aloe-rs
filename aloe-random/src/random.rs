crate::ix!();

//-------------------------------------------[.cpp/Aloe/modules/aloe_core/maths/aloe_Random.h]

/**
  | A random number generator.
  | 
  | You can create a Random object and use
  | it to generate a sequence of random numbers.
  | 
  | @tags{Core}
  |
  */
#[leak_detector]
pub struct Random {
    seed: i64,
}

impl Default for Random {
    
    /**
      | Creates a Random object using a random
      | seed value.
      | 
      | Internally, this calls setSeedRandomly()
      | to randomise the seed.
      |
      */
    fn default() -> Self {
    
        todo!();
        /*
        : seed(1),

            setSeedRandomly();
        */
    }
}

//-------------------------------------------[.cpp/Aloe/modules/aloe_core/maths/aloe_Random.cpp]
impl Random {

    /**
      | Returns the RNG's current seed.
      |
      */
    pub fn get_seed(&self) -> i64 {
        
        todo!();
        /*
            return seed;
        */
    }

    /**
      | Creates a Random object based on a seed
      | value.
      | 
      | For a given seed value, the subsequent
      | numbers generated by this object will
      | be predictable, so a good idea is to set
      | this value based on the time, e.g.
      | 
      | new Random (Time::currentTimeMillis())
      |
      */
    pub fn new(seed_value: i64) -> Self {
    
        todo!();
        /*
        : seed(seedValue),

        
        */
    }
    
    /**
      | Resets this Random object to a given
      | seed value.
      |
      */
    pub fn set_seed(&mut self, new_seed: i64)  {
        
        todo!();
        /*
            if (this == &getSystemRandom())
        {
            // Resetting the system Random risks messing up
            // Aloe's internal state. If you need a predictable
            // stream of random numbers you should use a local
            // Random object.
            jassertfalse;
            return;
        }

        seed = newSeed;
        */
    }
    
    /**
      | Merges this object's seed with another
      | value.
      | 
      | This sets the seed to be a value created
      | by combining the current seed and this
      | new value.
      |
      */
    pub fn combine_seed(&mut self, seed_value: i64)  {
        
        todo!();
        /*
            seed ^= nextInt64() ^ seedValue;
        */
    }
    
    /**
      | Reseeds this generator using a value
      | generated from various semi-random
      | system properties like the current
      | time, etc.
      | 
      | Because this function convolves the
      | time with the last seed value, calling
      | it repeatedly will increase the randomness
      | of the final result.
      |
      */
    pub fn set_seed_randomly(&mut self)  {
        
        todo!();
        /*
            static std::atomic<int64> globalSeed { 0 };

        combineSeed (globalSeed ^ (int64) (pointer_sized_int) this);
        combineSeed (Time::getMillisecondCounter());
        combineSeed (Time::getHighResolutionTicks());
        combineSeed (Time::getHighResolutionTicksPerSecond());
        combineSeed (Time::currentTimeMillis());
        globalSeed ^= seed;
        */
    }
    
    /**
      | The overhead of creating a new Random
      | object is fairly small, but if you want
      | to avoid it, you can call this method
      | to get a global shared Random object.
      | 
      | It's not thread-safe though, so threads
      | should use their own Random object,
      | otherwise you run the risk of your random
      | numbers becoming.. erm.. randomly
      | corrupted..
      |
      */
    pub fn get_system_random(&mut self) -> &mut Random {
        
        todo!();
        /*
            static Random sysRand;
        return sysRand;
        */
    }
    
    /**
      | Returns the next random 32 bit integer.
      | 
      | -----------
      | @return
      | 
      | a random integer from the full range
      | 0x80000000 to 0x7fffffff
      |
      */
    pub fn next_int(&mut self) -> i32 {
        
        todo!();
        /*
            seed = (int64) (((((uint64) seed) * 0x5deece66dLL) + 11) & 0xffffffffffffLL);

        return (int) (seed >> 16);
        */
    }
    
    /**
      | Returns the next random number, limited
      | to a given range.
      | 
      | The maxValue parameter may not be negative,
      | or zero.
      | 
      | -----------
      | @return
      | 
      | a random integer between 0 (inclusive)
      | and maxValue (exclusive).
      |
      */
    pub fn next_int_with_max(&mut self, max_value: i32) -> i32 {
        
        todo!();
        /*
            jassert (maxValue > 0);
        return (int) ((((unsigned int) nextInt()) * (uint64) maxValue) >> 32);
        */
    }
    
    /**
      | Returns the next random number, limited
      | to a given range.
      | 
      | -----------
      | @return
      | 
      | a random integer between the range start
      | (inclusive) and its end (exclusive).
      |
      */
    pub fn next_int_with_range(&mut self, range: Range<i32>) -> i32 {
        
        todo!();
        /*
            return range.getStart() + nextInt (range.getLength());
        */
    }
    
    /**
      | Returns the next 64-bit random number.
      | 
      | -----------
      | @return
      | 
      | a random integer from the full range
      | 0x8000000000000000 to 0x7fffffffffffffff
      |
      */
    pub fn next_int64(&mut self) -> i64 {
        
        todo!();
        /*
            return (int64) ((((uint64) (unsigned int) nextInt()) << 32) | (uint64) (unsigned int) nextInt());
        */
    }
    
    /**
      | Returns the next random boolean value.
      |
      */
    pub fn next_bool(&mut self) -> bool {
        
        todo!();
        /*
            return (nextInt() & 0x40000000) != 0;
        */
    }
    
    /**
      | Returns the next random floating-point
      | number.
      | 
      | -----------
      | @return
      | 
      | a random value in the range 0 (inclusive)
      | to 1.0 (exclusive)
      |
      */
    pub fn next_float(&mut self) -> f32 {
        
        todo!();
        /*
            auto result = static_cast<float> (static_cast<uint32> (nextInt()))
                      / (static_cast<float> (std::numeric_limits<uint32>::max()) + 1.0f);
        return result == 1.0f ? 1.0f - std::numeric_limits<float>::epsilon() : result;
        */
    }
    
    /**
      | Returns the next random floating-point
      | number.
      | 
      | -----------
      | @return
      | 
      | a random value in the range 0 (inclusive)
      | to 1.0 (exclusive)
      |
      */
    pub fn next_double(&mut self) -> f64 {
        
        todo!();
        /*
            return static_cast<uint32> (nextInt()) / (std::numeric_limits<uint32>::max() + 1.0);
        */
    }
    
    /**
      | Returns a BigInteger containing a random
      | number.
      | 
      | -----------
      | @return
      | 
      | a random value in the range 0 to (maximumValue
      | - 1).
      |
      */
    pub fn next_large_number(&mut self, maximum_value: &BigInteger) -> BigInteger {
        
        todo!();
        /*
            BigInteger n;

        do
        {
            fillBitsRandomly (n, 0, maximumValue.getHighestBit() + 1);
        }
        while (n >= maximumValue);

        return n;
        */
    }
    
    /**
      | Fills a block of memory with random values.
      |
      */
    pub fn fill_bits_randomly(&mut self, 
        buffer: *mut c_void,
        bytes:  usize)  {
        
        todo!();
        /*
            int* d = static_cast<int*> (buffer);

        for (; bytes >= sizeof (int); bytes -= sizeof (int))
            *d++ = nextInt();

        if (bytes > 0)
        {
            const int lastBytes = nextInt();
            memcpy (d, &lastBytes, bytes);
        }
        */
    }
    
    /**
      | Sets a range of bits in a BigInteger to
      | random values.
      |
      */
    pub fn fill_bits_randomly_in_bigint(
        &mut self, 
        array_to_change: &mut BigInteger,
        start_bit:       i32,
        num_bits:        i32)  {
        
        todo!();
        /*
            arrayToChange.setBit (startBit + numBits - 1, true);  // to force the array to pre-allocate space

        while ((startBit & 31) != 0 && numBits > 0)
        {
            arrayToChange.setBit (startBit++, nextBool());
            --numBits;
        }

        while (numBits >= 32)
        {
            arrayToChange.setBitRangeAsInt (startBit, 32, (unsigned int) nextInt());
            startBit += 32;
            numBits -= 32;
        }

        while (--numBits >= 0)
            arrayToChange.setBit (startBit + numBits, nextBool());
        */
    }
}
